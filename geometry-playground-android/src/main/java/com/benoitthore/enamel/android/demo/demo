
# With margin

## Draw Rect

val margin = 16.dp
canvas.drawRect(
    margin,
    margin,
    width - margin,
    height - margin,
    paintRect
)


## Draw Circle

val centerX = width / 2f
val centerY = height / 2f
val radius = width / 2f - margin

canvas.drawCircle(centerX, centerY, radius, paintCircle)


## With Enamel

frame
    .inset(16.dp)
    .draw(paintRect)
    .innerCircle()
    .draw(paintCircle)




# With relative size

## Without Enamel

val ratio = 0.5f

val w = width * ratio
val h = height * ratio
val cx = width / 2f
val cy = height / 2f

canvas.drawRect(
    cx - w / 2f, cy - h / 2f,
    cx + w / 2f, cy + h / 2f,
    paintRect
)

val radius = min(w, h) / 2
canvas.drawCircle(cx, cy, radius, paintCircle)

## With Enamel

PROBLEM
frame.scale(ratio,ratio)
  .draw(paintRect)
  .innerCircle()
  .draw(paintCircle)

SOLUTION
frame.scaleAnchor(ratio, 0.5,0.5)
    .draw(paintRect)
    .innerCircle()
    .draw(paintCircle)





# Rotating circles

## Inefficient memory management

Allo
var ratio = 0.5f

val nbOfPoints = 10

setContentView(
    canvasView { canvas ->


        frame
            .inset(width * 0.1)
            .innerCircle()
            .toListOfPoint(nbOfPoints, startAt = ratio.rotations())
            .map { it.toCircle(32.dp) }
            .forEachIndexed { i, circle ->
                paintCircle.color = colorHSL(i / nbOfPoints.f)
                circle.draw(paintCircle)
            }


    }.also { v ->
        v.backgroundColor = LTGRAY
        v.touchProgress { x, y ->
            ratio = y
            v.invalidate()
        }
    }
)

## Efficient memory management
AllocationTracker.debugAllocations = true

var ratio = 0.5f

        val nbOfPoints = 10

        val pool = GeometryPool()

        setContentView(
            canvasView { canvas ->

                frame
                    .inset(width * 0.1, pool.rectPool())
                    .innerCircle(pool.circlePool())
                    .toListOfPoint(
                        pool.pointPool(nbOfPoints),
                        startAt = ratio.rotations(pool.anglePool())
                    )
                    .map { it.toCircle(32.dp, pool.circlePool()) }
                    .forEachIndexed { i, circle ->
                        paintCircle.color = colorHSL(i / nbOfPoints.f)
                        circle.draw(paintCircle)
                    }


            }.also { v ->
                v.backgroundColor = LTGRAY
                v.touchProgress { x, y ->
                    ratio = y
                    v.invalidate()
                }
            }
        )




## Fancy coloured rainbow
  val noise = OpenSimplexNoise()
        var noiseOffset = 0f

        var ratio = 0.5f

        val nbOfPoints = 20

        val pool = GeometryPool()

        setContentView(
            canvasView { canvas ->

                frame
                    .inset(width , pool.rectPool())
                    .innerCircle(pool.circlePool())
                    .let { circle ->
                        circle.toListOfPoint(
                            pool.pointPool(nbOfPoints),
                            distanceList = (0 until nbOfPoints).map {
                                Scale.map(
                                    noise(it + noiseOffset),
                                    -1,
                                    1,
                                    circle.radius * 0.1,
                                    circle.radius
                                )
                            },
                            startAt = ratio.rotations(pool.anglePool())
                        )
                    }
                    .map { it.toCircle(16.dp, pool.circlePool()) }
                    .forEachIndexed { i, circle ->
                        paintCircle.color = colorHSL(i / nbOfPoints.f)
                        circle.draw(paintCircle)
                    }

                noiseOffset += 0.05f
                invalidate()


            }.also { v ->
                v.backgroundColor = LTGRAY
                v.touchProgress { x, y ->
                    ratio = y
                    v.invalidate()
                }
            }
        )